/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./scripts/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./scripts/Constraint.js":
/*!*******************************!*\
  !*** ./scripts/Constraint.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Constraint {\n    constructor(type, point1, point2, point3 = 0, point4 = 0, value = 0) {\n        this.type = type;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.point3 = point3;\n        this.point4 = point4;\n        this.value = value;\n        this._id = Constraint.counter;\n        this.watched = false;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    static get counter() {\n        Constraint._counter = (Constraint._counter || 0) + 1;\n        return Constraint._counter;\n    }\n\n    get solverFormat() {\n        let returnObj = {};\n\n        if (this.point1.id) { \n            returnObj.point1 = this.point1.id; \n        } else {\n            returnObj.point1 = 0;\n        }\n\n        if (this.point2.id) { \n            returnObj.point2 = this.point2.id; \n        } else {\n            returnObj.point2 = 0;\n        }\n\n        if (this.point3.id) { \n            returnObj.point3 = this.point3.id; \n        } else {\n            returnObj.point3 = 0;\n        }\n\n        if (this.point4.id) { \n            returnObj.point4 = this.point4.id; \n        } else {\n            returnObj.point4 = 0;\n        }\n\n        returnObj.Type = this.type;\n        returnObj.value = this.value;\n        return returnObj;\n\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Constraint);\n\n\n//# sourceURL=webpack:///./scripts/Constraint.js?");

/***/ }),

/***/ "./scripts/ConstraintTypes.js":
/*!************************************!*\
  !*** ./scripts/ConstraintTypes.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst ConstraintTypes = {\n    Distance_between_2_points: \"Distance_between_2_points\",\n    Parallelism_of_2_lines: \"Parallelism_of_2_lines\",\n    Perpendicularity_of_2_lines: \"Perpendicularity_of_2_lines\",\n    Horizontal_line: \"Horizontal_line\",\n    Vertical_line: \"Vertical_line\",\n    Belonging_point_to_line: \"Belonging_point_to_line\",\n    Angle_between_2_lines: \"Angle_between_2_lines\"\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ConstraintTypes);\n\n//# sourceURL=webpack:///./scripts/ConstraintTypes.js?");

/***/ }),

/***/ "./scripts/Line.js":
/*!*************************!*\
  !*** ./scripts/Line.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Line {\n    constructor(point1, point2) {\n        this.point1 = point1;\n        this.point2 = point2;\n        this.deleted = false;\n    }\n\n    draw(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(this.point1.x, this.point1.y);\n        ctx.lineTo(this.point2.x, this.point2.y);\n        ctx.stroke();\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Line);\n\n//# sourceURL=webpack:///./scripts/Line.js?");

/***/ }),

/***/ "./scripts/Point.js":
/*!**************************!*\
  !*** ./scripts/Point.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Point {\n    constructor(x, y, uniq = true) {\n        this.x = x;\n        this.y = y;\n        this.radius = 5;\n        this.fixed = false;\n        this.deleted = false;\n        if (uniq) this._id = Point.counter;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    static get counter() {\n        Point._counter = (Point._counter || 0) + 1;\n        console.log(Point._counter);\n        return Point._counter;\n    }\n\n    get solverFormat() {\n        return {\n            x: this.x,\n            y: this.y,\n            id: this.id,\n            fixed: this.fixed\n        };\n    }\n\n    draw(ctx) {\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fill();\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Point);\n\n//# sourceURL=webpack:///./scripts/Point.js?");

/***/ }),

/***/ "./scripts/SolverJson.js":
/*!*******************************!*\
  !*** ./scripts/SolverJson.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass SolverJson {\n    constructor(points, constraints, movablePointsIds) {\n        this.Points = points;\n        this.Constraints = constraints;\n        this.MovablePoints_id = movablePointsIds\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SolverJson);\n\n//# sourceURL=webpack:///./scripts/SolverJson.js?");

/***/ }),

/***/ "./scripts/Vector.js":
/*!***************************!*\
  !*** ./scripts/Vector.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Vector {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vector);\n\n//# sourceURL=webpack:///./scripts/Vector.js?");

/***/ }),

/***/ "./scripts/index.js":
/*!**************************!*\
  !*** ./scripts/index.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line */ \"./scripts/Line.js\");\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point */ \"./scripts/Point.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector */ \"./scripts/Vector.js\");\n/* harmony import */ var _Constraint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Constraint */ \"./scripts/Constraint.js\");\n/* harmony import */ var _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConstraintTypes */ \"./scripts/ConstraintTypes.js\");\n/* harmony import */ var _SolverJson__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SolverJson */ \"./scripts/SolverJson.js\");\n\n\n\n\n\n\n\n// Получаем javascript объекты HTML элементов по их id\nconst canvas = document.getElementById(\"canvas\");\nconst button_lines = document.getElementById(\"button_lines\");\nconst button_points = document.getElementById(\"button_points\");\nconst button_horizontal_line = document.getElementById(\"button_horizontal_line\");\nconst button_parallelism = document.getElementById(\"button_parallelism\");\nconst button_perpendicularity = document.getElementById(\"button_perpendicularity\");\nconst button_distance = document.getElementById(\"button_distance\");\nconst button_angle = document.getElementById(\"button_angle\");\nconst button_point_to_line = document.getElementById(\"button_point_to_line\");\nconst button_fix_point = document.getElementById(\"button_fix_point\");\nconst button_delete_point = document.getElementById(\"button_delete_point\");\nconst button_delete_line = document.getElementById(\"button_delete_line\");\n\nconst button_elements = [\n    button_lines, \n    button_points, \n    button_horizontal_line,\n    button_vertical_line, \n    button_parallelism, \n    button_perpendicularity,\n    button_distance,\n    button_angle,\n    button_point_to_line,\n    button_fix_point,\n    button_delete_point,\n    button_delete_line\n];\n\nconst makeButtonActive = (button_element) => {\n    button_element.style.backgroundColor = \"rgb(115, 193, 115)\";\n}\n\nconst makeButtonDefault = (button_element) => {\n    button_element.style.backgroundColor = \"\";\n}\n\nconst makeButtonsDefault = () => {\n    button_elements.forEach((button) => makeButtonDefault(button));\n}\n\nconst current_mode_element = document.getElementById(\"current_mode\");\ncurrent_mode_element.innerHTML = \"Перемещение\";\n\nconst getCurrentModeElementInnerHTML = (mode) => {\n    switch(mode) {\n        case ModesEnum.line:\n        case ModesEnum.drawingLine: return \"Отрезки\";\n        case ModesEnum.point: return \"Точки\";\n        case ModesEnum.limitations_horizontal_line: return \"Горизонтальность отрезка\";\n        case ModesEnum.limitations_vertical_line: return \"Вертикальность отрезка\";\n        case ModesEnum.limitations_parallelism: return \"Параллельность: 1 отрезок\";\n        case ModesEnum.limitations_parallelism_second: return \"Параллельность: 2 отрезок\";\n        case ModesEnum.limitations_perpendicularity: return \"Перпендикулярность: 1 отрезок\";\n        case ModesEnum.limitations_perpendicularity_second: return \"Перпендикулярность: 2 отрезок\";\n        case ModesEnum.limitations_distance: return \"Расстояние\";\n        case ModesEnum.limitations_angle: return \"Угол: 1 отрезок\";\n        case ModesEnum.limitations_angle_second: return \"Угол: 2 отрезок\";\n        case ModesEnum.limitations_point_to_line: return \"Принадлежность точки отрезку: точка\";\n        case ModesEnum.limitations_point_to_line_second: return \"Принадлежность точки отрезку: отрезок\";\n        case ModesEnum.moving:\n        case ModesEnum.moving_down_line:\n        case ModesEnum.moving_down_point: return \"Перемещение\";\n        case ModesEnum.limitations_fix_point: return \"Фиксация точки\";\n        case ModesEnum.delete_line: return \"Удаление линии\";\n        case ModesEnum.delete_point: return \"Удаление точки\";\n        default: return \"Перемещение\";\n    }\n}\n\n// Получаем контекст для рисования\nconst ctx = canvas.getContext('2d');\n\n// Состояния работы интерфейса\nconst ModesEnum = {\n    line: 2,\n    drawingLine: 3,\n    point: 4,\n\n    limitations_horizontal_line: 5,\n    limitations_vertical_line: 6,\n\n    limitations_parallelism: 7,\n    limitations_parallelism_second: 8,\n\n    limitations_perpendicularity: 9,\n    limitations_limitations_perpendicularity_second: 10,\n\n    limitations_distance: 11,\n\n    limitations_angle: 12,\n    limitations_angle_second: 13,\n\n    limitations_point_to_line: 14,\n    limitations_point_to_line_second: 15,\n\n    moving: 16,\n    moving_down_point: 17,\n    moving_down_line: 18,\n\n    limitations_fix_point: 19,\n\n    delete_point: 20,\n    delete_line: 21\n};\n  \n\nlet epsDist = 10;       // максимальное расстояние при выборе точки и отрезка\nlet epsDistMove = 9;    // аналогично, но только для перемещения точек и отрезков\n\nlet Points = new Map(); // ассоциативный контейнер, где ключ - это id точки, а значение - это объект класса Point\nlet Lines = [];         // массив из объектов класса Line\nlet Constraints = [];   // массив из объектов класса Constraint\n\nlet mode = ModesEnum.moving, prevMode; // mode - текущее состояние, prevMode - предыдущее состояние\n\nlet clickPoint, prevPoint;  // clickPoint - точка, на которую нажали, prevPoint - предыдущая точка\nlet clickLine, prevLine;    // аналогично\n\nlet movingPoint, movingLine;    // movingPoint - перемещаемая точка, movingLine - перемещаемая линия\n\n// Координаты верхней левой точки канваса, необходимо для получения относительных координат на канвасе\nlet canvasTopLeft = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"default\"](canvas.getBoundingClientRect().x, canvas.getBoundingClientRect().y, false); \n\ncanvas.height = canvas.parentElement.clientHeight;\ncanvas.width = canvas.parentElement.clientWidth;\n\n/*  \n    Данный код меняет размер канваса при изменении размеров окна. При желании его можно раскоментить, но тогда\n    надо закомментить следующий обработчик \n*/\n/*\nwindow.addEventListener(\"resize\", () => {\n    canvas.width  = window.innerWidth / 5 * 4;\n    canvas.height = window.innerHeight / 5 * 4;\n    canvasTopLeft = new Point(canvas.getBoundingClientRect().x, canvas.getBoundingClientRect().y, false);\n\n    let deltaHeight = (canvas.height - canvasHeight);\n    let deltaWidth  = (canvas.width - canvasWidth);\n\n    canvasHeight = canvas.height;\n    canvasWidth  = canvas.width;\n\n    for (let point of Points) {\n        if (point[1].x + deltaWidth > 0)  point[1].x += deltaWidth;\n        if (point[1].y + deltaHeight > 0) point[1].y += deltaHeight;\n    }\n\n    draw();\n});\n*/\n\n/* Обработчик на изменение размеров окна браузера. В этом случае необходимо переопределить координаты верхнего левого угла канваса */\nwindow.addEventListener(\"resize\", () => {\n    canvasTopLeft = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"default\"](canvas.getBoundingClientRect().x, canvas.getBoundingClientRect().y, false);\n});\n\n// Очищает канвас\nconst clear = () => {\n    ctx.save();\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\n\n// Отрисовывает на канвасе все точки и линии\nconst draw = () => {\n    clear();\n    for (let p of Points.values()) {\n        console.log(p);\n        if (!p.deleted) p.draw(ctx);\n    }\n    Lines.forEach(element => {\n        console.log(element);\n        if (!element.deleted) element.draw(ctx);\n    });\n}\n\n// Рисует линию от prevPoint до clickPoint\nconst onDrawLine = () => {\n    const line = new _Line__WEBPACK_IMPORTED_MODULE_0__[\"default\"](prevPoint, clickPoint);\n    Lines.push(line);\n    line.draw(ctx);\n}\n\n// Скалярное произведение\nconst dot = (point1, point2) => { return point1.x * point2.x + point1.y * point2.y; }\n\n// Расстояние между двумя точками\nconst dist = (point1, point2) => { \n    const dx = point2.x - point1.x; \n    const dy = point2.y - point1.y; \n    return Math.sqrt(dx * dx + dy * dy);\n}\n\n// Расстояние от точки P до вектоа P0P1\nconst distToLine = (P, P0, P1) => {\n    const numerator = (P1.y - P0.y) * P.x - (P1.x - P0.x) * P.y + P1.x * P0.y - P1.y * P0.x;\n    return Math.abs(numerator) / dist(P0, P1); \n}\n\n// Проверяет, имеется ли точка с pointId в ограничении constraint\nconst checkPointId = (pointId, constraint) => {\n    if (pointId === constraint.point1.id || \n        pointId === constraint.point2.id || \n        pointId === constraint.point3.id || \n        pointId === constraint.point4.id) {\n            return true;\n    }\n    return false;\n}\n\n// Возвращает массив pointId точек ограничения constraint\nconst getConstraintPointsIds = (constraint) => {\n    const pointsIds = [];\n    if (constraint.point1 && constraint.point1.id) { pointsIds.push(constraint.point1.id); }\n    if (constraint.point2 && constraint.point2.id) { pointsIds.push(constraint.point2.id); }\n    if (constraint.point3 && constraint.point3.id) { pointsIds.push(constraint.point3.id); }\n    if (constraint.point4 && constraint.point4.id) { pointsIds.push(constraint.point4.id); }\n    return pointsIds;\n}\n\n// Отмечает просмотренные ограничения полем watched = true\nconst noteRelatedRestrictions = (newConstraint) => {\n    newConstraint.watched = true;\n    const newConstraintPointIds = getConstraintPointsIds(newConstraint);\n    for (let pointId of newConstraintPointIds) {\n        for (let constraint of Constraints) {\n            if (!constraint.watched && checkPointId(pointId, constraint)) {\n                noteRelatedRestrictions(constraint);\n            }\n        }\n    }\n}\n\n// Возвращает вершины, связанные с ограничением newConstraint\nconst getConnectedPointsAndConstraints = (newConstraint) => {\n    noteRelatedRestrictions(newConstraint);\n    const resultConstraints = [];\n    const resultPointIdsSet = new Set();\n    for (let constraint of Constraints) {\n        if (constraint.watched) {\n            resultConstraints.push(constraint);\n            getConstraintPointsIds(constraint).forEach(pointId => resultPointIdsSet.add(pointId));\n        }\n        constraint.watched = false;\n    }\n    return {\n        connectedPointIds: Array.from(resultPointIdsSet), \n        connectedConstraints: resultConstraints\n    };\n}\n\n// Возвращает ближайшую точку minPoint и расстояние до нее minS от точки clickPoint\nconst getNearestPoint = (clickPoint) => {\n    let S, minS = Number.MAX_SAFE_INTEGER, minPoint;\n    Points.forEach(point => {\n        S = dist(clickPoint, point);\n        if (S < minS) {\n            minS = S;\n            minPoint = point;\n        }\n    });\n    return {minPoint, minS};\n}\n    \n// Возвращает ближайшую линию minLine и расстояние до нее minS от точки clickPoint\nconst getNearestLine = (clickPoint) => {\n    let S, minS = Number.MAX_SAFE_INTEGER, minLine;\n\n    Lines.forEach(line => {\n        const P  = clickPoint;\n        const P0 = line.point1;\n        const P1 = line.point2;\n\n        const w0 = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](P.x - P0.x, P.y - P0.y);\n        const w1 = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](P.x - P1.x, P.y - P1.y);\n        const v  = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](P1.x - P0.x, P1.y - P0.y);\n        const minus_v = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](-v.x, -v.y);\n\n        if (dot(w0, v) <= 0) {\n            S = dist(P, P0);\n        } else if (dot(w1, minus_v) <= 0) {\n            S = dist(P, P1);\n        } else {\n            S = distToLine(P, P0, P1);\n        }\n\n        if (S < minS) {\n            minS = S;\n            minLine = line;\n        }\n    });\n\n    return {minLine, minS};\n}\n\n// Возвращает массивы точек и ограничений в формате, необходимом для Solver\nconst getPointsAndConstraintsForSolver = (pointsIds, constraints) => {\n    const pointsForSolver = [];\n    pointsIds.forEach(pointId => {\n        pointsForSolver.push(Points.get(pointId).solverFormat);\n    });\n    const constraintsForSolver = [];\n    constraints.forEach(constraint => {\n        constraintsForSolver.push(constraint.solverFormat);\n    });\n    return {pointsForSolver, constraintsForSolver};\n}\n\n// Проверяет, существует ли уже аналогичное ограничение в системе\nconst sameConstraintExists = (newConstraint) => {\n    for (let constraint of Constraints) {\n        if (constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Horizontal_line && newConstraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Vertical_line ||\n            constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Vertical_line && newConstraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Horizontal_line) {\n                if (constraint.point1.id === newConstraint.point1.id && constraint.point2.id === newConstraint.point2.id) {\n                    return true;\n                }\n            }\n\n        if (constraint.type === newConstraint.type) {\n            if (constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Horizontal_line || constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Vertical_line) {\n                if (constraint.point1.id === newConstraint.point1.id && constraint.point2.id === newConstraint.point2.id) {\n                    return true;\n                }\n            }\n            if (constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Parallelism_of_2_lines || constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Perpendicularity_of_2_lines || constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Angle_between_2_lines) {\n                if (constraint.point1.id === newConstraint.point1.id && \n                    constraint.point2.id === newConstraint.point2.id &&\n                    constraint.point3.id === newConstraint.point3.id && \n                    constraint.point4.id === newConstraint.point4.id \n                    ||\n                    constraint.point1.id === newConstraint.point3.id && \n                    constraint.point2.id === newConstraint.point4.id &&\n                    constraint.point3.id === newConstraint.point1.id && \n                    constraint.point4.id === newConstraint.point2.id ) {\n                        return true;\n                    }\n            }\n            if (constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Distance_between_2_points) {\n                if (constraint.point1.id === newConstraint.point1.id && constraint.point2.id === newConstraint.point2.id) {\n                    return true;\n                }\n            }\n            if (constraint.type === _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Belonging_point_to_line) {\n                if (constraint.point1.id === newConstraint.point1.id && \n                    constraint.point2.id === newConstraint.point2.id &&\n                    constraint.point3.id === newConstraint.point3.id) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n// Выводит список точек в консоль\nconst showPoints = (newPoints) => {\n    for (let i = 0; i < newPoints.size(); i++) {\n        let Point = newPoints.get(i);\n\n        console.log(\"ID: \" + Point.get(0) + \n                    \"; X = \" + Point.get(1) + \n                    \"; Y = \" + Point.get(2));\n        console.log(\"\\n\");\n    }\n}\n\n// Изменяет координаты точек после получения решения от солвера\nconst changeCoordinatesAfterSolution = (newPoints) => {\n    for (let i = 0; i < newPoints.size(); i++) {\n        let Point = newPoints.get(i);\n        let id = Point.get(0);\n        let newX = Point.get(1);\n        let newY = Point.get(2);\n\n        console.log(\"ID: \" + Point.get(0) + \n                    \"; X = \" + Point.get(1) + \n                    \"; Y = \" + Point.get(2));\n        console.log(\"\\n\");\n        \n        Points.get(id).x = newX;\n        Points.get(id).y = newY;\n    }\n}    \n\n// Возвращает первое ограничение для точки\nconst getFirstConstraintForPoint = (point) => {\n    for (let constraint of Constraints) {\n        if (checkPointId(point.id, constraint)) {\n            return constraint;\n        }\n    }\n    return null;\n}\n\n// Возвращает первое ограничение для линии\nconst getFirstConstraintForLine = (line) => {\n    for (let constraint of Constraints) {\n        if (checkPointId(line.point1.id, constraint) || checkPointId(line.point2.id, constraint)) {\n            return constraint;\n        }\n    }\n    return null;\n}\n\nconst formSolverJson = (constraint, movablePoints) => {\n    const {connectedPointIds, connectedConstraints} = getConnectedPointsAndConstraints(constraint);\n    const {pointsForSolver, constraintsForSolver} = getPointsAndConstraintsForSolver(connectedPointIds, connectedConstraints);\n    const solverJson = new _SolverJson__WEBPACK_IMPORTED_MODULE_5__[\"default\"](pointsForSolver, constraintsForSolver, movablePoints);\n    console.log(solverJson);\n    return solverJson;\n}\n\nconst addConstraint = (constraint) => {\n    if (sameConstraintExists(constraint)) {\n        alert(\"such constraint already exists\");\n        return null;\n    }\n    Constraints.push(constraint);\n}\n\n// Функция-обработчик нажатия на канвас\nconst canvasOnClick = (e) => {\n    e.preventDefault();\n\n    if (mode === ModesEnum.moving) { return; }\n\n    if (mode >= ModesEnum.line && mode <= ModesEnum.point) {\n        clickPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"default\"](e.clientX - canvasTopLeft.x, e.clientY - canvasTopLeft.y);\n        switch(mode) {\n            case ModesEnum.line: {\n                clickPoint.draw(ctx);\n                Points.set(clickPoint.id, clickPoint);\n                prevPoint = clickPoint;\n                prevMode = mode;\n                mode = ModesEnum.drawingLine;\n                current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n                break;\n            }\n      \n            case ModesEnum.drawingLine: {\n                clickPoint.draw(ctx);\n                Points.set(clickPoint.id, clickPoint);\n                onDrawLine();\n                prevPoint = clickPoint;\n                prevMode = mode;\n                break;\n            }\n      \n            case ModesEnum.point: {\n                clickPoint.draw(ctx);\n                Points.set(clickPoint.id, clickPoint);\n                break;\n            }\n        }\n    }\n\n    clickPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"default\"](e.clientX - canvasTopLeft.x, e.clientY - canvasTopLeft.y, false);\n\n    switch(mode) {\n        case ModesEnum.limitations_vertical_line:\n        case ModesEnum.limitations_horizontal_line: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            clickLine = line;\n            let constraint;\n            if (mode === ModesEnum.limitations_vertical_line) {\n                constraint = new _Constraint__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Vertical_line, line.point1, line.point2);\n            } else {\n                constraint = new _Constraint__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Horizontal_line, line.point1, line.point2);\n            }\n\n            if (addConstraint(constraint) === null) return;\n            const solverJson = formSolverJson(constraint, [clickLine.point1.id, clickLine.point2.id]);\n            if (solverJson === null) return;\n            const newPoints = Module['Solver'](JSON.stringify(solverJson));\n            changeCoordinatesAfterSolution(newPoints);\n\n            draw();\n            break;\n        }\n\n        case ModesEnum.limitations_perpendicularity:\n        case ModesEnum.limitations_parallelism: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            prevLine = line;\n            prevMode = mode;\n\n            if (mode == ModesEnum.limitations_perpendicularity) \n                mode = ModesEnum.limitations_perpendicularity_second;\n            else\n                mode = ModesEnum.limitations_parallelism_second;\n            current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n            break;\n        }\n\n        case ModesEnum.limitations_perpendicularity_second:\n        case ModesEnum.limitations_parallelism_second: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            clickLine = line;\n\n            const constraintType = (mode === ModesEnum.limitations_perpendicularity_second) ?\n                _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Perpendicularity_of_2_lines :\n                _ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Parallelism_of_2_lines;\n            const constraint = new _Constraint__WEBPACK_IMPORTED_MODULE_3__[\"default\"](constraintType, prevLine.point1, prevLine.point2, clickLine.point1, clickLine.point2);\n\n            if (addConstraint(constraint) === null) return;\n            const solverJson = formSolverJson(constraint, [clickLine.point1.id, clickLine.point2.id]);\n            if (solverJson === null) return;\n            const newPoints = Module['Solver'](JSON.stringify(solverJson));\n            changeCoordinatesAfterSolution(newPoints);\n\n            draw();\n\n            prevMode = mode;\n            if (mode == ModesEnum.limitations_perpendicularity_second) \n                mode = ModesEnum.limitations_perpendicularity;\n            else \n                mode = ModesEnum.limitations_parallelism;\n            current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);    \n            break;\n        }\n\n        case ModesEnum.limitations_distance: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            clickLine = line;\n\n            let lineLength = -1;\n            while (lineLength <= 0 || isNaN(lineLength)) {\n                const lengthString = prompt(\"Введите длину отрезка.\", \"\");\n                if (lengthString === null) {\n                    return;\n                }\n                lineLength = Number(lengthString);\n                if (isNaN(lineLength)) {\n                    alert(\"Неверный ввод. Введите действительное число, которое больше 0.\");\n                } else if (lineLength <= 0) {\n                    alert(\"Значение длины должно быть больше 0.\");\n                }\n            }\n\n            const constraint = new _Constraint__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Distance_between_2_points, clickLine.point1, clickLine.point2, 0, 0, lineLength);\n\n            if (addConstraint(constraint) === null) return;\n            const solverJson = formSolverJson(constraint, [clickLine.point1.id, clickLine.point2.id]);\n            if (solverJson === null) return;\n            const newPoints = Module['Solver'](JSON.stringify(solverJson));\n            changeCoordinatesAfterSolution(newPoints);\n\n            draw();\n\n            break;\n        }\n\n        case ModesEnum.limitations_angle: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            clickLine = line;\n            prevLine = clickLine;\n\n            prevMode = mode;\n            mode = ModesEnum.limitations_angle_second;\n            current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n            break;\n        }\n\n        case ModesEnum.limitations_angle_second: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            clickLine = line;\n\n            let angleValue;\n            while (isNaN(angleValue)) {\n                const angleValueString = prompt(\"Введите угол.\", \"\");\n                if (angleValueString === null) {\n                    prevMode = mode;\n                    mode = ModesEnum.limitations_angle;\n                    return;\n                }\n                angleValue = Number(angleValueString);\n                if (isNaN(angleValue)) {\n                    alert(\"Неверный ввод. Введите действительное число, которое больше 0.\");\n                } \n            }\n\n            const constraint = new _Constraint__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Angle_between_2_lines, prevLine.point1, prevLine.point2, clickLine.point1, clickLine.point2, angleValue);\n\n            if (addConstraint(constraint) === null) return;\n            const solverJson = formSolverJson(constraint, [clickLine.point1.id, clickLine.point2.id]);\n            if (solverJson === null) return;\n            const newPoints = Module['Solver'](JSON.stringify(solverJson));\n            changeCoordinatesAfterSolution(newPoints);\n\n            draw();\n\n            prevMode = mode;\n            mode = ModesEnum.limitations_angle;\n            current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n            break;\n        }\n\n        case ModesEnum.limitations_point_to_line: {\n            const {minPoint: point, minS: distance} = getNearestPoint(clickPoint);\n            if (!point || distance > epsDist) return;\n\n            prevPoint = clickPoint = point;\n            prevMode = mode;\n            mode = ModesEnum.limitations_point_to_line_second;\n            current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n            break;\n        }\n\n        case ModesEnum.limitations_point_to_line_second: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            clickLine = line;\n\n            const constraint = new _Constraint__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_ConstraintTypes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Belonging_point_to_line, clickLine.point1, clickLine.point2, prevPoint);\n            \n            if (addConstraint(constraint) === null) return;\n            const solverJson = formSolverJson(constraint, [prevPoint.id, 0]);\n            if (solverJson === null) return;\n            const newPoints = Module['Solver'](JSON.stringify(solverJson));\n            changeCoordinatesAfterSolution(newPoints);\n            \n            draw();\n\n            prevMode = mode;\n            mode = ModesEnum.limitations_point_to_line;\n            current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n            break;\n        }\n\n        case ModesEnum.limitations_fix_point: {\n            const {minPoint: point, minS: distance} = getNearestPoint(clickPoint);\n            if (!point || distance > epsDist) return;\n\n            console.log(point);\n            point.fixed = true;\n            break;\n        }\n\n        case ModesEnum.delete_point: {\n            const {minPoint: point, minS: distance} = getNearestPoint(clickPoint);\n            if (!point || distance > epsDist) return;\n\n            Points.get(point.id).deleted = true;\n            draw();\n            break;\n        }\n\n        case ModesEnum.delete_line: {\n            const {minLine: line, minS: distance} = getNearestLine(clickPoint);\n            if (!line || distance > epsDist) return;\n\n            for (let l of Lines) {\n                if (l.point1 === line.point1 && l.point2 === line.point2) {\n                    l.deleted = true;\n                }\n            }\n            draw();\n            break;\n        }\n    }\n}\n\n// Функция - обработчик перемещения курсора\nconst canvasOnMouseMove = (e) => {\n    canvasTopLeft = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"default\"](canvas.getBoundingClientRect().x, canvas.getBoundingClientRect().y, false);\n    const prevPointForMoving = clickPoint;\n    clickPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"default\"](e.clientX - canvasTopLeft.x, e.clientY - canvasTopLeft.y, false);\n    console.log(\"canvas top left \", canvasTopLeft);\n    console.log(\"clickPoint \", clickPoint);\n\n    if (mode === ModesEnum.drawingLine) {\n        draw();\n        const line = new _Line__WEBPACK_IMPORTED_MODULE_0__[\"default\"](prevPoint, clickPoint);\n        line.draw(ctx);\n        return;\n    }\n\n\n    if (mode === ModesEnum.moving_down_point) {\n        // movePoint(movingPoint, clickPoint.x, clickPoint.y)\n        // draw();\n        if (movingPoint.fixed) return;\n        movePoint(movingPoint, clickPoint.x, clickPoint.y);\n        const constraint = getFirstConstraintForPoint(movingPoint);\n        if (constraint !== null) {\n            const solverJson = formSolverJson(constraint, [movingPoint.id, 0]);\n            console.log(solverJson);\n            const newPoints = Module['Solver'](JSON.stringify(solverJson));\n            changeCoordinatesAfterSolution(newPoints);\n        } \n        draw();\n        return;\n    }\n\n    if (mode === ModesEnum.moving_down_line) {\n        if (movingLine.point1.fixed && movingLine.point2.fixed) return;\n        if (movingLine.point1.fixed) { \n            movePointOnDelta(movingLine.point2, clickPoint.x - prevPointForMoving.x, clickPoint.y - prevPointForMoving.y); \n        } else if (movingLine.point2.fixed) {\n            movePointOnDelta(movingLine.point1, clickPoint.x - prevPointForMoving.x, clickPoint.y - prevPointForMoving.y); \n        } else {\n            moveLine(movingLine, clickPoint.x - prevPointForMoving.x, clickPoint.y - prevPointForMoving.y);\n        }\n        \n        const constraint = getFirstConstraintForLine(movingLine);\n        if (constraint !== null) {\n            const solverJson = formSolverJson(constraint, [movingLine.point1.id, movingLine.point2.id]);\n            console.log(solverJson);\n            const newPoints = Module['Solver'](JSON.stringify(solverJson));\n            changeCoordinatesAfterSolution(newPoints);\n        } \n        draw();\n        return;\n    }\n}\n\n// Функция - обработчик нажатия правой кнопки мыши\nconst canvasOnRightClick = (e) => {\n    e.preventDefault();\n\n    if (mode === ModesEnum.drawingLine) {\n        if (prevMode === ModesEnum.line) {\n            Points.delete(prevPoint.id);\n        }\n        mode = ModesEnum.line;\n        current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n        draw();\n    } else {\n        prevMode = mode;\n        mode = ModesEnum.moving;\n        current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n        makeButtonsDefault();\n    }\n}\n\n// Функция - обработчик нажатия и удержания левой кнопки мыши\nconst canvasOnMouseDown = (e) => {\n    e.preventDefault();\n    if (mode === ModesEnum.moving) {\n        clickPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"default\"](e.clientX - canvasTopLeft.x, e.clientY - canvasTopLeft.y, false);\n        const {minPoint: point, minS: distance} = getNearestPoint(clickPoint);\n        if (point && distance < epsDistMove) {\n            prevMode = mode;\n            mode = ModesEnum.moving_down_point;\n            movingPoint = point;\n        } else {\n            const {minLine: line, minS: dist} = getNearestLine(clickPoint);\n            if (line && dist < epsDistMove) {\n                prevMode = mode;\n                mode = ModesEnum.moving_down_line;\n                movingLine = line;\n                prevPoint = clickPoint;\n            }\n        }\n    }\n}\n\n// Функция - обработчик отпускания левой кнопки мыши\nconst canvasOnMouseUp = (e) => {\n    if (mode === ModesEnum.moving_down_point || mode === ModesEnum.moving_down_line) {\n        prevMode = mode;\n        mode = ModesEnum.moving;\n    }\n}\n\n// Задает новые координаты точки point\nconst movePoint = (point, newX, newY) => {\n    point.x = newX;\n    point.y = newY;\n}\n\nconst movePointOnDelta = (point, deltaX, deltaY) => {\n    point.x += deltaX;\n    point.y += deltaY;\n}\n\n// Изменяет имеющиеся координаты концов линий\nconst moveLine = (line, deltaX, deltaY) => {\n    line.point1.x += deltaX;\n    line.point1.y += deltaY;\n    line.point2.x += deltaX;\n    line.point2.y += deltaY;\n}\n\n// Дальше идут функции - обработчки нажатий на кнопки над канвасом\nconst button_lines_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.line;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_lines);\n}\n\nconst button_points_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.point;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_points);\n}\n\nconst button_horizontal_line_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_horizontal_line;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_horizontal_line);\n}\n\nconst button_vertical_line_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_vertical_line;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_vertical_line);\n}\n\nconst button_parallelism_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_parallelism;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_parallelism);\n}\n\nconst button_perpendicularity_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_perpendicularity;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_perpendicularity);\n}\n\nconst button_distance_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_distance;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_distance);\n}\n\nconst button_angle_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_angle;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_angle);\n}\n\nconst button_point_to_line_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_point_to_line;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_point_to_line);\n}\n\nconst button_fix_point_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.limitations_fix_point;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_fix_point);\n}\n\nconst button_delete_point_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.delete_point;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_delete_point);\n}\n\nconst button_delete_line_onClick = (e) => {\n    prevMode = mode;\n    mode = ModesEnum.delete_line;\n    current_mode_element.innerHTML = getCurrentModeElementInnerHTML(mode);\n    makeButtonsDefault();\n    makeButtonActive(button_delete_line);\n}\n\n// Навешивание функций-обработчиков на события\ncanvas.addEventListener('click', canvasOnClick);\ncanvas.addEventListener('contextmenu', canvasOnRightClick)\ncanvas.addEventListener('mousemove', canvasOnMouseMove);\ncanvas.addEventListener('mousedown', canvasOnMouseDown);\ncanvas.addEventListener('mouseup', canvasOnMouseUp);\n\nbutton_lines.addEventListener('click', button_lines_onClick);\nbutton_points.addEventListener('click', button_points_onClick);\nbutton_horizontal_line.addEventListener('click', button_horizontal_line_onClick);\nbutton_vertical_line.addEventListener('click', button_vertical_line_onClick);\nbutton_parallelism.addEventListener('click', button_parallelism_onClick);\nbutton_perpendicularity.addEventListener('click', button_perpendicularity_onClick);\nbutton_distance.addEventListener('click', button_distance_onClick);\nbutton_angle.addEventListener('click', button_angle_onClick);\nbutton_point_to_line.addEventListener('click', button_point_to_line_onClick);\nbutton_fix_point.addEventListener('click', button_fix_point_onClick);\nbutton_delete_point.addEventListener('click', button_delete_point_onClick);\nbutton_delete_line.addEventListener('click', button_delete_line_onClick);\n\n//# sourceURL=webpack:///./scripts/index.js?");

/***/ })

/******/ });